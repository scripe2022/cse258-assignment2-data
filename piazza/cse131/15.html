{"result":{"history_size":1,"folders":["project","project∕project1"],"nr":15,"data":{"embed_links":[]},"created":"2024-04-14T02:39:23Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"stud","data":"luyx3nf07xo76e","v":"all","type":"create","when":"2024-04-14T02:39:23Z","uid_a":"a_0"},{"anon":"no","uid":"l8co2ln9yg87fy","data":"luyytyymqcu62d","to":"luyx3netpzj76c","type":"i_answer","when":"2024-04-14T03:27:51Z"}],"bucket_name":"Today","history":[{"anon":"stud","uid_a":"a_0","subject":"Understanding the Reaching Definition Algorithm","created":"2024-04-14T02:39:23Z","content":"<p>I&#39;m a bit confused about how the algorithm for reaching definitions covered in lecture 3 can be applied to eliminate dead code. For example, assuming we have calculated the fixed point IN and OUT sets for every block, how can we check if some definition statement s1 in block b1 reaches usage statement s2 in block b2? </p>\n<p></p>\n<p>Furthermore, I&#39;m wondering about the correctness of a DFS approach to this problem. If we start at definition statement s1, why can&#39;t we run DFS traversing the CFG until we find a usage statement (in which case s1 will be live)? I recognize the big-O complexity is probably much worse for this approach but it seems easier to implement for the project.</p>"}],"type":"question","tags":["project","project∕project1","student"],"tag_good":[{"role":"student","name":"David Tran","endorser":{"lmhwg5qdgc46vu":1702599657,"global":1709773823,"lp0fztse6d42p3":1709773823},"admin":false,"photo":null,"id":"krqvn6kpl8b3nf","photo_url":null,"published":true,"us":false,"facebook_id":null}],"unique_views":37,"children":[{"history_size":1,"folders":[],"data":{"embed_links":[]},"created":"2024-04-14T03:27:51Z","bucket_order":3,"tag_endorse":[],"bucket_name":"Today","history":[{"anon":"no","uid":"l8co2ln9yg87fy","subject":"","created":"2024-04-14T03:27:51Z","content":"<p>You will need to build a basic CFG first, so you will have access to each block. If s1 or s2 are connected, then you should be able to visit s2 to check; the details of the code will depend on how you write the program. You can traverse all previous blocks to see whether the definition exists when you need to decide which instruction to be marked as deletion. </p>\n<p></p>\n<p>The lecture discusses a more general and runtime-efficient approach. You may eventually find that these are easier to code. There are other approaches to completing the project.</p>"}],"type":"i_answer","tag_endorse_arr":[],"children":[],"id":"luyytyygiyq62c","config":{"editor":"rte"},"is_tag_endorse":false}],"tag_good_arr":["krqvn6kpl8b3nf"],"no_answer":0,"id":"luyx3netpzj76c","config":{"editor":"rte","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":2,"num_favorites":0,"my_favorite":false,"is_bookmarked":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1731990936207,"default_anonymity":"no"},"error":null,"aid":"m3nyoneko445fu"}