{"result":{"history_size":1,"folders":["project","project∕project1"],"nr":24,"data":{"embed_links":[]},"created":"2024-04-21T06:00:58Z","bucket_order":3,"no_answer_followup":5,"change_log":[{"anon":"no","uid":"kfo6q50fd7g4em","data":"lv94dujtaft1s1","v":"all","type":"create","when":"2024-04-21T06:00:58Z"},{"anon":"stud","data":"lv97s558ptq7ea","to":"lv94dujkfli1s0","type":"s_answer","when":"2024-04-21T07:36:04Z","uid_a":"a_0"},{"anon":"stud","data":"lv97spinmk768","type":"s_answer_update","when":"2024-04-21T07:36:30Z","uid_a":"a_0"},{"anon":"no","uid":"luigot8o2sy6fl","data":"lv97ubv8py81ms","type":"s_answer_update","when":"2024-04-21T07:37:46Z"},{"anon":"stud","data":"lv97uv9vkr323m","type":"s_answer_update","when":"2024-04-21T07:38:11Z","uid_a":"a_0"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"followup","when":"2024-04-21T07:39:33Z","cid":"lv97wmd6g2b5nn"},{"anon":"stud","data":"lv9ajsigldtg9","type":"s_answer_update","when":"2024-04-21T08:53:33Z","uid_a":"a_0"},{"anon":"no","uid":"luhmx33gqzp7i5","data":"lv9aw0t1n9v69g","type":"s_answer_update","when":"2024-04-21T09:03:04Z"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"followup","when":"2024-04-21T09:06:30Z","cid":"lv9b0g2qfyw1o7"},{"anon":"stud","data":"lv9b4addoym4fs","type":"s_answer_update","when":"2024-04-21T09:09:29Z","uid_a":"a_0"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"followup","when":"2024-04-21T09:10:52Z","cid":"lv9b621bzom72n"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"followup","when":"2024-04-21T09:11:55Z","cid":"lv9b7en8desgy"},{"anon":"no","uid":"luigot8o2sy6fl","to":"lv94dujkfli1s0","type":"feedback","when":"2024-04-21T09:14:21Z","cid":"lv9baj3gasl2j5"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"feedback","when":"2024-04-21T09:16:39Z","cid":"lv9bdi064ia5dh"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"followup","when":"2024-04-21T09:21:48Z","cid":"lv9bk4aovm33i4"},{"anon":"no","uid":"luigot8o2sy6fl","to":"lv94dujkfli1s0","type":"feedback","when":"2024-04-21T09:45:52Z","cid":"lv9cf2rsca21e3"},{"anon":"no","uid":"kfo6q50fd7g4em","to":"lv94dujkfli1s0","type":"feedback","when":"2024-04-21T15:17:16Z","cid":"lv9o994u9xy2uv"}],"bucket_name":"Today","history":[{"anon":"no","uid":"kfo6q50fd7g4em","subject":"Project 1 Reaching Definition - GEN edge case","created":"2024-04-21T06:00:58Z","content":"<md>Hi,\n\nMy project partner and I are struggling with this problem. In the lecture slides, it says that GEN[S] is defined as the set of definitions in S, where S is a basic block. However, we are not sure if this encompasses multiple definitions of the same variable in S. In other words: if there are multiple definitions of some variable `x` in the same basic block, should all these definitions get added to GEN[S]?\n\nIntuitively, it seems as though the answer is no. It seems as though we should only add the most recent definition to GEN[S]. But we run into a problem when it comes to arrays. Consider the following code snippet:\n```\n...\n    array_store, ti, A, j\n    array_store, tj, A, i\n```\n\nFrom the compiler's point of view, there is no way to determine whether this is referring to the same location, i.e. the same index in the same array, at compile time. Determining whether `j = i` would require the compiler to actually execute the code, which is not what we want to do. But if we enforce the requirement that each variable in each block should have at most one definition associated with it in `GEN(S)`, then we would have to figure out whether `j = i`, which as mentioned above seems unrealistic.\n\nIn the example above, should `GEN(S)` contain only the first instruction? Or should it contain both?</md>"}],"type":"question","tags":["project","project∕project1","student"],"tag_good":[{"role":"student","name":"Albert Ai","endorser":{"lmhwg5qdgc46vu":1699931133},"admin":false,"photo":null,"id":"kfo6pmpsdyk32u","photo_url":null,"published":true,"us":false,"facebook_id":null}],"unique_views":40,"children":[{"history_size":7,"folders":[],"data":{"embed_links":[]},"created":"2024-04-21T07:36:04Z","bucket_order":3,"tag_endorse":[],"bucket_name":"Today","history":[{"anon":"stud","uid_a":"a_0","subject":"","created":"2024-04-21T09:09:29Z","content":"<code>array_store</code> doesn’t change the value of a variable, do you mean <code>array_load</code>? <strong>The following analysis is based on the assumption that you intended to write <code>array_load</code> instead of <code>array_store</code>.</strong><br /><br />In your example, I think <code>GEN[s]</code> should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into <code>GEN,</code> then it is in the <code>OUT</code> of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of <code>OUT.</code><br /><br />In my opinion, the array here is more like a way to access the memory, because when you want to use a value in it, say <code>A[i]</code>, you need to first load it into a variable, which is a definition of the variable. So, the store action does not change a variable, thus it&#39;s not a definition. In your example, the two <code>array_store</code> instructions are not definition, so the first one won&#39;t be overwritten by the second one.<br />When it comes to two adjacent definitions on the same variable, if this variable is not used in the second definition, then for any later usage of this variable, the second definition exists as an intervening definition between the first one and the usage, and the second instruction overwrites the first one."},{"anon":"no","uid":"luhmx33gqzp7i5","subject":"","created":"2024-04-21T09:03:04Z","content":"<code>array_store</code> doesn’t change the value of a variable, do you mean <code>array_load</code>? The following analysis is based on the assumption that you intended to write <code>array_load</code> instead of <code>array_store</code>.\n\nIn your example, I think <code>GEN[s]</code> should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into <code>GEN,</code> then it is in the <code>OUT</code> of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of <code>OUT.</code>\n\nIn my opinion, the array here is more like a way to access the memory, because when you want to use a value in it, say <code>A[i]</code>, you need to first load it into a variable, which is a definition of the variable. So, the store action does not change a variable, thus it&#39;s not a definition. In your example, the two <code>array_store</code> instructions are not definition, so the first one won&#39;t be overwritten by the second one.\nWhen it comes to two adjacent definitions on the same variable, if this variable is not used in the second definition, then for any later usage of this variable, the second definition exists as an intervening definition between the first one and the usage, and the second instruction overwrites the first one."},{"anon":"stud","uid_a":"a_0","subject":"","created":"2024-04-21T08:53:33Z","content":"<md>`array_store` doesn't change the value of a variable, do you mean `array_load`? The following analysis is based on the assumption that you intended to write `array_load` instead of `array_store`.\n\nIn your example, I think `GEN[s]` should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into `GEN,` then it is in the `OUT` of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of `OUT.`</md>"},{"anon":"stud","uid_a":"a_0","subject":"","created":"2024-04-21T07:38:11Z","content":"<md>`array_store` doesn't change the value of a variable, do you mean `array_load`?\n\nIn your example, I think `GEN[s]` should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into `GEN,` then it is in the `OUT` of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of `OUT.`</md>"},{"anon":"no","uid":"luigot8o2sy6fl","subject":"","created":"2024-04-21T07:37:46Z","content":"<md>`array_store` doesn't change the value of a variable, do you mean `array_load`?\n\nIn your example, I think `GEN[s]` should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into `GEN,` then it is in the `OUT` of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of `OUT.`</md>"},{"anon":"stud","uid_a":"a_0","subject":"","created":"2024-04-21T07:36:30Z","content":"<md>`array_store` doesn't change the value of a variable, do you mean `array_load`?\n\nIn your example, I think `GEN[s]` should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into `GEN,` then it is in the `OUT` of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of `OUT.`</md>"},{"anon":"stud","uid_a":"a_0","subject":"","created":"2024-04-21T07:36:04Z","content":"<md>`array_store` doesn't change the value of a variable, do you mean `array_load`?\n\nIn your example, I think `GEN[s]` should only contain the last instruction. As $$OUT[s] = GEN[s] \\cup (IN[S] - KILL[S])$$, if you add the first one into `GEN,` then it is in the `OUT` of this basic block. However, for being overwritten by the second instruction, the first instruction cannot reach the exit of this block apparently, which disobeys the definition of `OUT.`</md>"}],"type":"s_answer","tag_endorse_arr":[],"children":[],"id":"lv97s553xik7e9","config":{"editor":"rte"},"is_tag_endorse":false},{"anon":"no","folders":[],"data":{"embed_links":null},"no_upvotes":0,"subject":"<p>`array_store` does change the array, which by all purposes is a variable. Unless you&#39;re saying we should omit arrays from dataflow analysis, which will result in very wrong dead code removals.</p>\n<div></div>\n<div>I am not sure how you came to the conclusion that the second will always overwrite the first. If i is not equal to j, then A[j] and A[i] will refer to two different locations in the array, so how would the second instruction overwrite the first? Please explain to me, because I do not understand this.</div>","created":"2024-04-21T07:39:33Z","bucket_order":3,"bucket_name":"Today","type":"followup","tag_good":[],"uid":"kfo6q50fd7g4em","children":[{"anon":"no","folders":[],"data":{"embed_links":null},"subject":"<md>I don't think dead code elimination by reaching definition introduced in slides is strong enough to optimize array. We cannot trace the definition of members in array using IN set and OUT set.</md>","created":"2024-04-21T09:14:21Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[],"uid":"luigot8o2sy6fl","children":[],"tag_good_arr":[],"id":"lv9baj3gasl2j5","d-bucket":"Yesterday","updated":"2024-04-21T09:14:21Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":{"embed_links":null},"subject":"<md>So you want to just mark all arrays as critical?\n\nIf I have a program that writes to some array, and then returns the constant \"1\", then you want to keep the array write just because it's an array, even though it has *nothing* to do with the answer? This does not make sense to me.</md>","created":"2024-04-21T09:16:39Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[],"uid":"kfo6q50fd7g4em","children":[],"tag_good_arr":[],"id":"lv9bdi064ia5dh","d-bucket":"Yesterday","updated":"2024-04-21T09:18:28Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":{"embed_links":null},"subject":"<md>I just said with knowledge of this course so far, we can do nothing to array optimization. IN set and OUT set are invalid for tracing definition of array members; instead, this may come into effect if treating array as a variable storing a memory address.\n\nBesides, I think you cannot say if an array write is not related to the answer, then it is unnecessarry. In C/C++,  we can pass a pointer as an argument to a function and ask that function to write data into the memory that the pointer points to. In this case, the function may have no return but the array write is critical.</md>","created":"2024-04-21T09:45:52Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[],"uid":"luigot8o2sy6fl","children":[],"tag_good_arr":[],"id":"lv9cf2rsca21e3","d-bucket":"Yesterday","updated":"2024-04-21T09:52:00Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":{"embed_links":null},"subject":"But the array is not the same thing as a pointer.<div><br /></div><div>With pointers, you truly cannot be sure if two pointers point to the same location. However, with arrays in Tiger-IR, you can be sure that arrays A and B will never point to the same location, no matter what index you access inside those arrays.<div><br /></div><div>Suppose I use array A to compute some complex operation, like a quick sort over the input (given as integers). Then, I write &#34;2&#34; to array B[0] and return B[0]. In this . program, it is very clear that only B is a &#34;critical array&#34;, while any code related to A is dead code that can be eliminated. In Tiger-IR, there will never be a case where writing to array A will affect a value in value B. Again, arrays are not the same thing as pointers.</div></div>","created":"2024-04-21T15:17:16Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"kfo6q50fd7g4em","children":[],"tag_good_arr":[],"id":"lv9o994u9xy2uv","updated":"2024-04-21T15:17:16Z","config":{}}],"tag_good_arr":[],"no_answer":1,"id":"lv97wmd6g2b5nn","updated":"2024-04-21T15:17:16Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":{"embed_links":null},"no_upvotes":0,"subject":"<md>\"In your example, the two array\\_store instructions are not definition, so the first one won't be overwritten by the second one. When it comes to two adjacent definitions on the same variable, if this variable is not used in the second definition, then for any later usage of this variable, the second definition exists as an intervening definition between the first one and the usage, and the second instruction overwrites the first one.\"\n\nI already explained why this is not necessarily true. If I have code that writes to `A[i]` then `A[j]`, but `i` and `j` are variables inside the code which may or may not be equal to each other depending on the input given to the program, then I have no way of determining at compile time whether the second definition will exist as a intervening definition between the first one and the usage.</md>","created":"2024-04-21T09:06:30Z","bucket_order":4,"bucket_name":"Yesterday","type":"followup","tag_good":[],"uid":"kfo6q50fd7g4em","children":[],"tag_good_arr":[],"no_answer":1,"id":"lv9b0g2qfyw1o7","d-bucket":"Yesterday","updated":"2024-04-21T09:06:30Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":{"embed_links":null},"no_upvotes":0,"subject":"<md>I am not asking about `array_load`, I care about `array_store` because I care about the case when we are WRITING to the array, not reading from it. Putting it in bold will not change my question.</md>","created":"2024-04-21T09:10:52Z","bucket_order":4,"bucket_name":"Yesterday","type":"followup","tag_good":[],"uid":"kfo6q50fd7g4em","children":[],"tag_good_arr":[],"no_answer":1,"id":"lv9b621bzom72n","d-bucket":"Yesterday","updated":"2024-04-21T09:11:07Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":{"embed_links":null},"no_upvotes":0,"subject":"<md>\"In my opinion, the array here is more like a way to access the memory, because when you want to use a value in it, say A\\[i\\], you need to first load it into a variable, which is a definition of the variable.\"\n\nSo you want to exclude arrays from the data flow analysis altogether? Suppose you have a program that writes to an array, and then loads some array data into a variable, and then returns that variable. Then if you do not even care about arrays, then your data flow analysis will conclude that actually the writing to the array is unnecessary, and will delete that from your program during dead code removal. Which will be incorrect.</md>","created":"2024-04-21T09:11:55Z","bucket_order":4,"bucket_name":"Yesterday","type":"followup","tag_good":[],"uid":"kfo6q50fd7g4em","children":[],"tag_good_arr":[],"no_answer":1,"id":"lv9b7en8desgy","d-bucket":"Yesterday","updated":"2024-04-21T09:11:55Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":{"embed_links":null},"no_upvotes":0,"subject":"<md>Update: I believe the correct approach is to treat the array itself as a variable you write AND read to, when `array_store` is called. (and still keep the property of having at most one instruction per variable per block in GEN)\n\nWhen you write to one element of the array, it is equivalent to creating a new array, reading everything but the element you are overwriting from the current array to that new array, writing the element you are overwriting to the correct position in the new array, and then overwriting the whole original array with the new array. So, in this sense, you are writing to AND reading from the array when you call `array_store`. Similar to how, in the instruction `add, a, a, 1`, you are writing to AND reading from the variable `a`.</md>","created":"2024-04-21T09:21:48Z","bucket_order":4,"bucket_name":"Yesterday","type":"followup","tag_good":[],"uid":"kfo6q50fd7g4em","children":[],"tag_good_arr":[],"no_answer":1,"id":"lv9bk4aovm33i4","d-bucket":"Yesterday","updated":"2024-04-21T09:24:42Z","config":{"editor":"md"}}],"tag_good_arr":["kfo6pmpsdyk32u"],"no_answer":0,"id":"lv94dujkfli1s0","config":{"editor":"md","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":3,"num_favorites":0,"my_favorite":false,"is_bookmarked":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1731990945335,"default_anonymity":"no"},"error":null,"aid":"m3nyoug9t2k3pp"}