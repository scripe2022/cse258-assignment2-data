{"result":{"history_size":3,"folders":["project","project∕project1"],"nr":18,"data":{"embed_links":[]},"created":"2024-04-16T23:49:51Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"no","uid":"kfo6q50fd7g4em","data":"lv31d6rwpvi75s","v":"all","type":"create","when":"2024-04-16T23:49:51Z"},{"anon":"no","uid":"kfo6q50fd7g4em","data":"lv31dnncg4kgw","v":"all","type":"update","when":"2024-04-16T23:50:13Z"},{"anon":"no","uid":"kfo6q50fd7g4em","data":"lv31hczg9gp1q7","v":"all","type":"update","when":"2024-04-16T23:53:06Z"},{"anon":"no","uid":"kfo6q50fd7g4em","data":"lv31o4o5rkdht","to":"lv31d6rp2dq75q","type":"s_answer","when":"2024-04-16T23:58:22Z"}],"bucket_name":"Today","history":[{"anon":"no","uid":"kfo6q50fd7g4em","subject":"Does dead code elimination even affect dynamic instruction count?","created":"2024-04-16T23:53:06Z","content":"<md>In the Project 1 spec, it says that our submission will be graded relative to a reference optimizer that uses dead code elimination using reaching definitions. Specifically, we will be graded on the dynamic instruction count of the code that passes through our optimizer, compared to the dynamic instruction count when the code is passed through the reference optimizer instead. We will get full credit if our dynamic instruction count is less or equal to the reference optimizer's dynamic instruction point\n\nHowever, I have one question: if the reference optimizer just does dead code elimination, will it actually improve the dynamic instruction count at all, relative to the unoptimized IR code? If dead code is by definition code that never gets executed, then removing that dead code will not have any impact on the number of instructions that get executed when the program is run.\n\nSo, by that logic, if I have a \"null optimizer\" (an optimizer that literally does nothing and just spits out the IR code it was given), why won't that get full credit under the scoring scheme specified in the PDF? It seems as though the dead code elimination optimizer won't decrease dynamic instruction count anyway.</md>"},{"anon":"no","uid":"kfo6q50fd7g4em","subject":"Does dead code elimination even affect dynamic instruction count?","created":"2024-04-16T23:50:13Z","content":"<md>In the Project 1 spec, it says that our submission will be graded relative to a reference optimizer that uses dead code elimination using reaching definitions. Specifically, we will be graded on the dynamic instruction count of the code that passes through our optimizer, compared to the dynamic instruction count when the code is passed through the reference optimizer instead. We will get full credit if our dynamic instruction count is greater or equal to the reference optimizer's dynamic instruction point\n\nHowever, I have one question: if the reference optimizer just does dead code elimination, will it actually improve the dynamic instruction count at all, relative to the unoptimized IR code? If dead code is by definition code that never gets executed, then removing that dead code will not have any impact on the number of instructions that get executed when the program is run.\n\nSo, by that logic, if I have a \"null optimizer\" (an optimizer that literally does nothing and just spits out the IR code it was given), why won't that get full credit under the scoring scheme specified in the PDF? It seems as though the dead code elimination optimizer won't decrease dynamic instruction count anyway.</md>"},{"anon":"no","uid":"kfo6q50fd7g4em","subject":"Does dead code elimination even affect dynamic instruction count?","created":"2024-04-16T23:49:51Z","content":"<md>In the Project 1 spec, it says that our submission will be graded relative to a reference optimizer that uses dead code elimination using reaching definitions. Specifically, we will be graded on the dynamic instruction count of the code that passes through our optimizer, compared to the dynamic instruction count when the code is passed through the reference optimizer instead. We will get full credit if our dynamic instruction count is greater or equal to the reference optimizer's dynamic instruction point\n\nHowever, I have one question: if the reference optimizer just does dead code elimination, will it actually improve the dynamic instruction count at all, relative to the unoptimized IR code? If dead code is by definition code that never gets executed, then removing that dead code will not have any impact on the number of instructions that get executed when the program is run.\n\nSo, by that logic, if I have a \"null optimizer\" (an optimizer that literally does nothing and just spits out the IR code it was given), why won't that get full credit under the scoring scheme specified in the PDF?</md>"}],"type":"question","tags":["project","project∕project1","student"],"tag_good":[],"unique_views":39,"children":[{"history_size":1,"folders":[],"data":{"embed_links":[]},"created":"2024-04-16T23:58:22Z","bucket_order":3,"tag_endorse":[{"role":"ta","name":"Shaokang Jiang","endorser":{},"admin":true,"photo":null,"id":"l8co2ln9yg87fy","photo_url":null,"published":true,"us":false,"facebook_id":null}],"bucket_name":"Today","history":[{"anon":"no","uid":"kfo6q50fd7g4em","subject":"","created":"2024-04-16T23:58:22Z","content":"<md>Wait, I realized that dead code doesn't necessarily refer to code that never gets executed, but rather refers to *any* code that doesn't make a difference in the \"final product\"</md>"}],"type":"s_answer","tag_endorse_arr":["l8co2ln9yg87fy"],"children":[],"id":"lv31o4nyquuhr","config":{"editor":"md"},"is_tag_endorse":false}],"tag_good_arr":[],"no_answer":0,"id":"lv31d6rp2dq75q","config":{"editor":"md","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":1,"num_favorites":0,"my_favorite":false,"is_bookmarked":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1731990939247,"default_anonymity":"no"},"error":null,"aid":"m3nyopr6fj25in"}